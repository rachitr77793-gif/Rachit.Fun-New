<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rachit.Fun â€” Draw</title>
<style>
  :root{
    --card:#fff;
    --edge:#071133;
    --muted:#64748b;
    --accent:#0ea5a3;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background:#f7fbff;
    color:var(--edge);
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  /* exact ribbon style from your snippet */
  .topbar{
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:12px 18px;
    background:transparent;
    border-bottom:1px solid rgba(0,0,0,0.03);
    position:sticky;
    top:0;
    z-index:50;
  }
  .left { display:flex; align-items:center; gap:12px; font-weight:800; }
  .left .logo{font-size:20px}
  .left .site{font-size:20px}
  .right { display:flex; align-items:center; gap:10px; }

  .color-picker{ width:36px; height:28px; border-radius:8px; border:1px solid #ccc; padding:0; cursor:pointer}
  .score-pill{padding:6px 10px;border-radius:999px;background:linear-gradient(180deg,#fff,#f1f5f9);border:1px solid rgba(0,0,0,0.06);font-weight:700}
  .btn{ background:var(--card); border:1px solid rgba(0,0,0,0.06); padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:700; display:inline-flex; gap:8px; align-items:center; }
  .btn.primary{ background:linear-gradient(90deg,var(--accent), #06b6b4); color:#fff; border:none; }

  /* page container */
  .wrap{max-width:1100px;margin:18px auto;padding:0 14px}

  /* toolbar (exact simple row you wanted) */
  .taskbar{
    display:flex;
    gap:12px;
    align-items:center;
    padding:12px 14px;
    margin-top:10px;
    background:transparent;
  }
  .tool-label{font-weight:700;color:var(--muted);font-size:13px;margin-right:6px}

  .tools-left{display:flex;gap:8px;align-items:center}
  .tools-right{margin-left:auto;display:flex;gap:8px;align-items:center}

  /* canvas area */
  .canvas-wrap{
    margin-top:12px;
    background:linear-gradient(180deg,#ffffff,#fcfeff);
    border-radius:12px;
    padding:12px;
    box-shadow: 0 10px 30px rgba(10,20,40,0.06);
    border:1px solid rgba(0,0,0,0.04);
  }
  .game-screen{
    width:100%;
    height:640px;
    background: #ffffff;
    border-radius:10px;
    position:relative;
    overflow:hidden;
    display:flex;
    flex-direction:column;
  }
  .screen-top{
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:10px 12px;
    border-bottom:1px solid rgba(7,16,34,0.04);
    background:linear-gradient(180deg, rgba(255,255,255,0.85), rgba(255,255,255,0.6));
  }
  .screen-title{font-weight:800}
  .screen-body{
    flex:1;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:12px;
    background:
      linear-gradient(45deg, rgba(0,0,0,0.03) 25%, transparent 25%, transparent 75%, rgba(0,0,0,0.03) 75%),
      linear-gradient(45deg, rgba(0,0,0,0.03) 25%, transparent 25%, transparent 75%, rgba(0,0,0,0.03) 75%);
    background-size:18px 18px;
    background-position: 0 0, 9px 9px;
  }

  canvas{ background:#ffffff; border-radius:6px; box-shadow: 0 8px 20px rgba(9,25,51,0.04); max-width:100%; max-height:100%; touch-action:none; }

  .bottom-controls{
    display:flex;
    gap:8px;
    align-items:center;
    padding:10px;
    border-top:1px solid rgba(7,16,34,0.04);
    background:linear-gradient(180deg, rgba(255,255,255,0.95), rgba(255,255,255,0.9));
  }

  input[type=range]{width:120px}
  .swatch{ width:32px; height:32px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); cursor:pointer; display:inline-block }

  .text-bar{display:flex;align-items:center;gap:8px;margin-left:6px}
  .text-bar input{padding:8px;border-radius:8px;border:1px solid rgba(0,0,0,0.06);min-width:220px}
  .hint{font-size:12px;color:var(--muted);margin-left:6px}

  footer{margin-top:12px;font-size:12px;color:var(--muted);text-align:center}

  @media (max-width:900px){
    canvas{ max-height:520px }
    .game-screen{ height:520px }
  }
  @media (max-width:480px){
    .game-screen{ height:420px }
    .text-bar input{min-width:120px}
  }
</style>
</head>
<body>
  <!-- topbar matching your MazeEscape taskbar -->
  <header class="topbar">
    <div class="left">
      <div class="logo">ðŸŽ®</div>
      <div class="site">Rachit.Fun</div>
    </div>
    <div class="right">
      <label style="display:flex;align-items:center;gap:8px;font-weight:700">
        BG <input id="bgPicker" class="color-picker" type="color" value="#f7fbff" />
      </label>
      <button class="btn" id="homeBtn">Home</button>
      <button class="btn" id="resetAllBtn">Reset All</button>
    </div>
  </header>

  <div class="wrap">
    <!-- Simple toolbar: Thickness | Color | Eraser | Clear | Save -->
    <div class="taskbar" role="toolbar" aria-label="draw controls">
      <div class="tools-left">
        <div class="tool-label">Draw</div>
        <div style="display:flex;align-items:center;gap:8px">
          <label class="tool-label">Thickness</label>
          <input id="brushSize" type="range" min="1" max="80" value="6" />
          <div id="sizeLabel" style="font-weight:800;width:36px;text-align:center">6</div>
        </div>

        <div style="display:flex;align-items:center;gap:8px">
          <label class="tool-label">Color</label>
          <div class="swatch" id="quickBlack" data-color="#000000" style="background:#000000"></div>
          <div class="swatch" id="quickGray" data-color="#4B5563" style="background:#4B5563"></div>
          <div class="swatch" id="quickAqua" data-color="#06B6D4" style="background:#06B6D4"></div>
          <input id="colorPicker" type="color" class="color-picker" value="#000000" />
        </div>

        <button class="btn" id="eraserBtn">Eraser</button>
        <button class="btn" id="clearBtn">Clear</button>
        <button class="btn primary" id="saveBtn">Save</button>
      </div>

      <div class="tools-right">
        <div class="text-bar">
          <label class="tool-label">Text</label>
          <input id="textInput" placeholder="Type text then click canvas to place" />
          <div class="hint">Click canvas to place text</div>
        </div>
      </div>
    </div>

    <div class="canvas-wrap">
      <div class="game-screen" role="application" aria-label="Draw screen">
        <div class="screen-top">
          <div class="screen-title">Draw</div>
          <div style="color:var(--muted);font-weight:700">Rachit.Fun</div>
        </div>

        <div class="screen-body">
          <canvas id="drawCanvas" width="1024" height="640" aria-label="drawing canvas"></canvas>
        </div>

        <div class="bottom-controls">
          <div style="font-size:13px;color:var(--muted)">Status: <span id="status">Ready</span></div>
          <div style="flex:1"></div>
          <div style="font-size:13px;color:var(--muted)">Tip: Use two fingers to scroll on mobile, draw with one</div>
        </div>
      </div>
    </div>

    <footer>Made for Rachit.Fun â€” exact toolbar layout as requested</footer>
  </div>

<script>
/* Persist BG exactly like MazeEscape */
const BG_KEY = 'rachit_bg';
const bgPicker = document.getElementById('bgPicker');
const saved = localStorage.getItem(BG_KEY);
if (saved) {
  document.body.style.background = saved;
  bgPicker.value = saved;
}
bgPicker.addEventListener('input', e => {
  document.body.style.background = e.target.value;
  localStorage.setItem(BG_KEY, e.target.value);
});
document.getElementById('homeBtn').addEventListener('click', () => {
  window.location.href = 'HomePagefinal.html';
});
document.getElementById('resetAllBtn').addEventListener('click', () => {
  if (!confirm('Reset everything? This clears BG setting.')) return;
  localStorage.removeItem(BG_KEY);
  location.reload();
});

/* DRAW APP LOGIC */
(function(){
  const canvas = document.getElementById('drawCanvas');
  const ctx = canvas.getContext('2d', { alpha: true });

  // tools
  const brushSize = document.getElementById('brushSize');
  const sizeLabel = document.getElementById('sizeLabel');
  const colorPicker = document.getElementById('colorPicker');
  const quickBlack = document.getElementById('quickBlack');
  const quickGray = document.getElementById('quickGray');
  const quickAqua = document.getElementById('quickAqua');
  const eraserBtn = document.getElementById('eraserBtn');
  const clearBtn = document.getElementById('clearBtn');
  const saveBtn = document.getElementById('saveBtn');
  const status = document.getElementById('status');
  const textInput = document.getElementById('textInput');

  let drawing = false;
  let last = { x:0, y:0 };
  let tool = 'pen'; // or 'eraser'
  let strokeColor = colorPicker.value;
  let strokeWidth = +brushSize.value;
  let strokeAlpha = 1.0;

  // Undo stack
  const undoStack = [];
  const MAX_STACK = 30;

  function pushState() {
    try {
      if (undoStack.length >= MAX_STACK) undoStack.shift();
      undoStack.push(canvas.toDataURL('image/png'));
    } catch(e){}
  }

  // initialize canvas with white bg
  function initCanvas() {
    canvas.width = 1024;
    canvas.height = 640;
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    pushState();
    resizeToContainerIfAuto();
  }

  // Maintain responsive fit similar to past pages
  function resizeToContainerIfAuto() {
    const wrap = canvas.parentElement;
    const parentRect = wrap.getBoundingClientRect();
    const maxW = Math.max(320, parentRect.width - 10);
    const maxH = Math.max(240, parentRect.height - 10);
    const ratio = canvas.width / canvas.height;
    let w = maxW, h = Math.round(w / ratio);
    if (h > maxH) { h = maxH; w = Math.round(h * ratio); }
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
  }

  // pointer coordinate conversion
  function toCanvasCoords(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const x = (clientX - rect.left) * (canvas.width / rect.width);
    const y = (clientY - rect.top) * (canvas.height / rect.height);
    return { x, y };
  }

  function beginStroke(x,y) {
    drawing = true;
    last = { x, y };
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineWidth = tool === 'eraser' ? Math.max(8, strokeWidth*1.5) : strokeWidth;
    ctx.globalAlpha = strokeAlpha;
    ctx.strokeStyle = tool === 'eraser' ? '#ffffff' : strokeColor;
    status.textContent = tool === 'eraser' ? 'Eraser' : 'Drawing';
  }

  function continueStroke(x,y) {
    if (!drawing) return;
    const midX = (last.x + x) / 2;
    const midY = (last.y + y) / 2;
    ctx.quadraticCurveTo(last.x, last.y, midX, midY);
    ctx.stroke();
    last = { x, y };
  }

  function endStroke() {
    if (!drawing) return;
    drawing = false;
    ctx.closePath();
    pushState();
    status.textContent = 'Ready';
  }

  // Pointer events
  canvas.addEventListener('pointerdown', (e) => {
    if (e.pointerType === 'mouse' && e.button !== 0) return;
    canvas.setPointerCapture(e.pointerId);
    const p = toCanvasCoords(e.clientX, e.clientY);
    beginStroke(p.x, p.y);
    e.preventDefault();
  });
  canvas.addEventListener('pointermove', (e) => {
    if (!drawing) return;
    const p = toCanvasCoords(e.clientX, e.clientY);
    continueStroke(p.x, p.y);
    e.preventDefault();
  });
  canvas.addEventListener('pointerup', (e) => {
    if (drawing) endStroke();
    try { canvas.releasePointerCapture(e.pointerId); } catch(e){}
    e.preventDefault();
  });
  canvas.addEventListener('pointercancel', () => endStroke());

  // For placing text: user types text and clicks canvas to stamp it
  canvas.addEventListener('click', (e) => {
    const txt = textInput.value.trim();
    if (!txt) return;
    const p = toCanvasCoords(e.clientX, e.clientY);
    // draw text onto canvas (push state before change)
    pushState();
    ctx.save();
    ctx.fillStyle = strokeColor;
    ctx.globalAlpha = 1.0;
    // choose font size relative to canvas height
    const fontSize = Math.round(canvas.height * 0.04);
    ctx.font = `${fontSize}px Inter, Arial`;
    ctx.textBaseline = 'top';
    // simple outline for visibility
    ctx.lineWidth = Math.max(2, Math.round(fontSize * 0.12));
    ctx.strokeStyle = '#ffffff';
    ctx.strokeText(txt, p.x, p.y);
    ctx.fillText(txt, p.x, p.y);
    ctx.restore();
  });

  // Toolbar bindings
  brushSize.addEventListener('input', (e) => {
    strokeWidth = +e.target.value;
    sizeLabel.textContent = strokeWidth;
  });

  colorPicker.addEventListener('input', (e) => {
    strokeColor = e.target.value;
    setPen();
  });
  [quickBlack, quickGray, quickAqua].forEach(el => {
    el.addEventListener('click', () => {
      const c = el.getAttribute('data-color') || '#000';
      colorPicker.value = c;
      strokeColor = c;
      setPen();
    });
  });

  function setPen() {
    tool = 'pen';
    eraserBtn.classList.remove('primary');
    status.textContent = 'Ready';
  }

  eraserBtn.addEventListener('click', () => {
    if (tool === 'eraser') { setPen(); } else {
      tool = 'eraser';
      eraserBtn.classList.add('primary');
      status.textContent = 'Eraser';
    }
  });

  clearBtn.addEventListener('click', () => {
    if (!confirm('Clear the canvas? This can be undone via Undo (Ctrl+Z).')) return;
    // clear and fill white
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    pushState();
  });

  // Save (download PNG)
  saveBtn.addEventListener('click', () => {
    // draw white background below to avoid transparent result
    const tmp = document.createElement('canvas');
    tmp.width = canvas.width;
    tmp.height = canvas.height;
    const tctx = tmp.getContext('2d');
    tctx.fillStyle = '#ffffff';
    tctx.fillRect(0,0,tmp.width,tmp.height);
    tctx.drawImage(canvas, 0, 0);
    tmp.toBlob((blob) => {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const stamp = new Date().toISOString().replace(/[:.]/g,'-');
      a.download = `rachitfun_draw_${stamp}.png`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }, 'image/png');
  });

  // Undo with Ctrl+Z
  window.addEventListener('keydown', (e) => {
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
      e.preventDefault();
      doUndo();
    } else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y') {
      e.preventDefault();
      // no redo implemented in simple version to keep exact look, but we could add later
    }
  });

  function doUndo() {
    if (!undoStack.length) return;
    // pop current (last) state and restore previous if exists
    // we keep the last entry as current; remove it then restore the previous
    // If only one state, restore blank
    undoStack.pop(); // remove current
    const last = undoStack[undoStack.length-1];
    if (!last) {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      return;
    }
    const img = new Image();
    img.onload = () => {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    };
    img.src = last;
  }

  // initialize
  initCanvas();

  // responsive resizing without changing drawing resolution:
  window.addEventListener('resize', () => {
    resizeToContainerIfAuto();
  });
})();
  <script src="redirect.js"></script>

</script>
</body>
</html>

