<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rachit.Fun â€” 2048 (fixed)</title>
<style>
  :root{
    --bg:#f1f8fb;
    --card:#ffffff;
    --muted:#64748b;
    --edge:#071133;
    --panel:#dbe6ee;
    --gap:14px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background:var(--bg);
    color:var(--edge);
    -webkit-font-smoothing:antialiased;
  }

  /* TASKBAR */
  .topbar{
    display:flex;justify-content:space-between;align-items:center;padding:12px 20px;
    background:transparent;border-bottom:1px solid rgba(0,0,0,0.03);position:sticky;top:0;z-index:50;
  }
  .left{display:flex;align-items:center;gap:12px;font-weight:800}
  .left .logo{font-size:20px}
  .left .site{font-size:20px}
  .right{display:flex;align-items:center;gap:10px}
  .color-picker{width:36px;height:28px;border-radius:8px;border:1px solid #ccc;padding:0;cursor:pointer}
  .btn{background:var(--card);border:1px solid rgba(0,0,0,0.06);padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:700}

  /* layout */
  .wrap{max-width:920px;margin:18px auto;padding:12px;display:flex;flex-direction:column;align-items:center}
  h1{margin:18px 0 6px;font-size:30px}

  .board-wrap{
    background:var(--panel);padding:18px;border-radius:12px;display:flex;flex-direction:column;align-items:center;
    box-shadow:0 10px 30px rgba(12,15,30,0.03);
  }

  /* Controls above board (Start / Reset) */
  .top-controls{display:flex;gap:18px;align-items:center;margin-bottom:12px;flex-wrap:wrap;justify-content:center}
  .action-btn{
    background:#fff;border:4px solid #000;padding:12px 20px;border-radius:6px;font-weight:900;font-size:18px;
    letter-spacing:2px;cursor:pointer;font-family:"Patrick Hand","Indie Flower",Inter,Arial,sans-serif;
  }

  .hint{font-size:13px;color:#334155;font-weight:700}

  /* grid container */
  .grid{
    width:360px;
    height:360px;
    display:grid;
    grid-template-columns:repeat(4,1fr);
    grid-gap:var(--gap);
    padding:var(--gap);
    border-radius:12px;
    background:rgba(255,255,255,0.95);
  }
  .cell{
    width:100%;
    height:100%;
    border-radius:10px;
    background:rgba(255,255,255,0.9);
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:800;
    color:var(--edge);
    font-size:28px;
    position:relative;
    overflow:hidden;
  }

  /* tile element placed inside cell */
  .tile {
    width:100%;
    height:100%;
    border-radius:10px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:900;
    transition: transform 140ms cubic-bezier(.2,.9,.2,1), background 120ms, color 120ms;
    box-shadow: 0 8px 16px rgba(9,25,51,0.04);
    font-size:28px;
  }
  .tile.appear{ transform: scale(0.6); opacity:0; animation: appear .16s ease forwards; }
  @keyframes appear { to { transform:scale(1); opacity:1; } }

  .scoreboard{display:flex;gap:18px;align-items:center;margin-top:14px;font-weight:800}
  .score{background:#fff;padding:8px 12px;border-radius:10px;border:1px solid rgba(0,0,0,0.06)}

  #status{margin-top:12px;color:var(--muted);font-weight:700}

  /* responsive */
  @media (max-width:480px){
    .grid{width:280px;height:280px}
    .action-btn{padding:10px 14px;font-size:16px}
    .tile{font-size:20px}
  }
</style>
</head>
<body>
  <header class="topbar">
    <div class="left">
      <div class="logo">ðŸŽ®</div>
      <div class="site">Rachit.Fun</div>
    </div>

    <div class="right">
      <label style="display:flex;align-items:center;gap:8px;font-weight:700">
        BG
        <input id="bgPicker" class="color-picker" type="color" value="#f1f8fb" />
      </label>

      <button class="btn" id="homeBtn">Home</button>
      <button class="btn" id="resetAllBtn">Reset All</button>
    </div>
  </header>

  <div class="wrap">
    <h1>2048</h1>

    <div class="board-wrap" id="boardWrap">
      <!-- Buttons above the grid now -->
      <div class="top-controls">
        <button id="startBtn" class="action-btn">START</button>
        <button id="resetBtn" class="action-btn">RESET</button>
      </div>

      <!-- grid (tiles rendered INSIDE cells) -->
      <div class="grid" id="grid"></div>

      <div class="scoreboard" style="margin-top:18px">
        <div class="score">Score: <span id="score">0</span></div>
        <div class="score">Best: <span id="best">0</span></div>
      </div>

      <div id="status">Press START to begin</div>
    </div>
  </div>

<script>
/* ---------- TASKBAR BG Persistence ---------- */
const BG_KEY = 'rachit_bg';
const bgPicker = document.getElementById('bgPicker');
const savedBG = localStorage.getItem(BG_KEY);
if (savedBG) { document.body.style.background = savedBG; bgPicker.value = savedBG; }
bgPicker.addEventListener('input', e => { document.body.style.background = e.target.value; localStorage.setItem(BG_KEY, e.target.value); });
document.getElementById('homeBtn').addEventListener('click', ()=> window.location.href='HomePagefinal.html');
document.getElementById('resetAllBtn').addEventListener('click', ()=> { if(confirm('Reset everything?')){ localStorage.removeItem(BG_KEY); location.reload(); } });

/* ---------- 2048 game (fixed rendering) ---------- */
const SIZE = 4;
let board = [];
let score = 0;
let best = Number(localStorage.getItem('rachit_2048_best') || 0);
document.getElementById('best').textContent = best;

const gridEl = document.getElementById('grid');
const scoreEl = document.getElementById('score');
const statusEl = document.getElementById('status');
const startBtn = document.getElementById('startBtn');
const resetBtn = document.getElementById('resetBtn');
let running = false;

/* create 16 empty cells in grid (keeps spacing correct) */
function createGridCells(){
  gridEl.innerHTML = '';
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.r = r;
      cell.dataset.c = c;
      gridEl.appendChild(cell);
    }
  }
}

/* initialize empty board data structure */
function initEmptyBoard(){
  board = [];
  for(let r=0;r<SIZE;r++){
    const row = [];
    for(let c=0;c<SIZE;c++) row.push(0);
    board.push(row);
  }
}

/* place a random tile 2 or 4 */
function addRandomTile(){
  const empties = [];
  for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if(board[r][c] === 0) empties.push([r,c]);
  if(empties.length === 0) return false;
  const [r,c] = empties[Math.floor(Math.random()*empties.length)];
  board[r][c] = Math.random() < 0.9 ? 2 : 4;
  return [r,c];
}

/* apply tile styles similar to screenshot */
function tileStyle(value){
  const colors = {
    0: ['#ffffff','#000000'],
    2: ['#f8fafc','#071133'],
    4: ['#f8faf8','#071133'],
    8: ['#fdeecd','#071133'],
    16: ['#fbd89e','#071133'],
    32: ['#fbbe63','#071133'],
    64: ['#fb9852','#fff'],
    128: ['#f57c3f','#fff'],
    256: ['#f2503f','#fff'],
    512: ['#e73a35','#fff'],
    1024: ['#d22d2a','#fff'],
    2048: ['#c21f23','#fff'],
    4096: ['#8b1a9f','#fff']
  };
  return colors[value] || ['#ececec','#071133'];
}

/* render board: for each cell place a .tile element when value > 0 */
function renderBoard(animateNew=false){
  // update each cell content
  const cells = gridEl.querySelectorAll('.cell');
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      const idx = r*SIZE + c;
      const cell = cells[idx];
      cell.innerHTML = ''; // clear
      const val = board[r][c];
      if(val !== 0){
        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.textContent = val;
        const [bg, color] = tileStyle(val);
        tile.style.background = bg;
        tile.style.color = color;
        // if animateNew flag and this cell was newly added recently, add appear class
        if(animateNew && (recentAdded && recentAdded[0] === r && recentAdded[1] === c)){
          tile.classList.add('appear');
        }
        cell.appendChild(tile);
      }
    }
  }
}

/* Score handling */
function setScore(s){
  score = s;
  scoreEl.textContent = score;
  if(score > best){
    best = score;
    localStorage.setItem('rachit_2048_best', String(best));
    document.getElementById('best').textContent = best;
  }
}

/* Movement logic: use left-logic after rotations (same as previous but simpler) */
function initEmptyBoardReturn(){
  const nb = [];
  for(let r=0;r<SIZE;r++){ nb[r]=[]; for(let c=0;c<SIZE;c++) nb[r][c]=0; }
  return nb;
}
function cloneBoard(b){ return b.map(row => row.slice()); }
function rotateCW(b){
  const n = SIZE;
  const nb = initEmptyBoardReturn();
  for(let r=0;r<n;r++) for(let c=0;c<n;c++) nb[c][n-1-r] = b[r][c];
  return nb;
}
function rotateCCW(b){
  const n = SIZE;
  const nb = initEmptyBoardReturn();
  for(let r=0;r<n;r++) for(let c=0;c<n;c++) nb[n-1-c][r] = b[r][c];
  return nb;
}
function moveLeft(b){
  const n = SIZE;
  let moved = false;
  let points = 0;
  const nb = initEmptyBoardReturn();
  for(let r=0;r<n;r++){
    let target=0;
    let last=0;
    for(let c=0;c<n;c++){
      const val = b[r][c];
      if(val === 0) continue;
      if(last === 0){
        last = val;
      } else {
        if(last === val){
          nb[r][target] = last*2;
          points += last*2;
          target++;
          last = 0;
          moved = true;
        } else {
          nb[r][target] = last;
          target++;
          last = val;
        }
      }
    }
    if(last !== 0) nb[r][target] = last;
    // detect movement by comparing rows
    for(let c=0;c<n;c++) if(nb[r][c] !== b[r][c]) moved = true;
  }
  return {board: nb, moved, points};
}
function applyMove(direction){
  if(!running) return;
  let rb = cloneBoard(board);
  if(direction === 'up') rb = rotateCCW(rb);
  else if(direction === 'right') rb = rotateCW(rotateCW(rb));
  else if(direction === 'down') rb = rotateCW(rb);

  const res = moveLeft(rb);
  let nb = res.board;
  if(direction === 'up') nb = rotateCW(nb);
  else if(direction === 'right') nb = rotateCW(rotateCW(nb));
  else if(direction === 'down') nb = rotateCCW(nb);

  if(res.moved){
    board = nb;
    setScore(score + res.points);
    const added = addRandomTile();
    recentAdded = added || null;
    renderBoard(true);
    // check moves available after small delay
    setTimeout(()=> {
      if(!movesAvailable()){
        setStatus('Game Over â€” no moves!');
        running = false;
      }
    }, 160);
  }
}

function movesAvailable(){
  for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if(board[r][c] === 0) return true;
  for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){
    const v = board[r][c];
    if(r+1 < SIZE && board[r+1][c] === v) return true;
    if(c+1 < SIZE && board[r][c+1] === v) return true;
  }
  return false;
}

/* UI helpers */
function setStatus(s){ statusEl.textContent = s; }

let recentAdded = null;

/* START / RESET */
startBtn.addEventListener('click', ()=>{
  initEmptyBoard();
  setScore(0);
  addRandomTile();
  addRandomTile();
  recentAdded = null;
  renderBoard(true);
  running = true;
  setStatus('Use arrows / WASD or swipe to move');
});

resetBtn.addEventListener('click', ()=>{
  if(!confirm('Reset the game?')) return;
  initEmptyBoard();
  setScore(0);
  renderBoard();
  running = false;
  setStatus('Press START to begin');
});

/* keyboard / touch handlers */
window.addEventListener('keydown', (e)=>{
  if(!running) return;
  if(e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') applyMove('left');
  if(e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') applyMove('right');
  if(e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') applyMove('up');
  if(e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') applyMove('down');
});

/* swipe */
let startX=0, startY=0;
window.addEventListener('touchstart', (ev)=>{
  if(!running) return;
  const t = ev.touches[0];
  startX = t.clientX; startY = t.clientY;
});
window.addEventListener('touchend', (ev)=>{
  if(!running) return;
  if(!ev.changedTouches || ev.changedTouches.length===0) return;
  const t = ev.changedTouches[0];
  const dx = t.clientX - startX; const dy = t.clientY - startY;
  if(Math.abs(dx) < 20 && Math.abs(dy) < 20) return;
  if(Math.abs(dx) > Math.abs(dy)){
    if(dx > 0) applyMove('right'); else applyMove('left');
  } else {
    if(dy > 0) applyMove('down'); else applyMove('up');
  }
});

/* initial build */
createGridCells();
initEmptyBoard();
renderBoard();
setScore(0);
setStatus('Press START to begin');
</script>
</body>
</html>


