<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rachit.Fun ‚Äî Tetris</title>
<style>
  :root{--card:#fff}
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:#f7fbff;color:#071133;display:flex;flex-direction:column;align-items:center;}

  /* --------- TASKBAR (exact as you gave) --------- */
  .topbar{
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:12px 20px;
    background:transparent;
    border-bottom:1px solid rgba(0,0,0,0.03);
    position:sticky;
    top:0;
    z-index:50;
    width:100%;
  }
  .left {display:flex;align-items:center;gap:12px;font-weight:800}
  .left .logo{font-size:20px}
  .left .site{font-size:20px}
  .right {display:flex;align-items:center;gap:10px}
  .color-picker{width:36px;height:28px;border-radius:8px;border:1px solid #ccc;padding:0}
  .btn{background:var(--card);border:1px solid rgba(0,0,0,0.06);padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:700}

  /* --------- Page layout --------- */
  .main {
    max-width:920px;
    width:100%;
    padding:30px 20px;
    display:flex;
    flex-direction:column;
    align-items:center;
  }

  .title {
    font-size:34px;
    font-weight:900;
    margin-bottom:18px;
  }

  .game-card{
    width:360px;
    background:#fff;
    border-radius:14px;
    padding:18px;
    box-shadow:0 6px 24px rgba(8,24,64,0.06);
    display:flex;
    flex-direction:column;
    align-items:center;
  }

  canvas#tetrisCanvas{
    background:linear-gradient(180deg,#e6f4ff,#dff2ff);
    border-radius:8px;
    box-shadow: inset 0 0 0 3px #000; /* thin inner border to match your look */
    display:block;
  }

  .controls {
    margin-top:14px;
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:10px;
  }

  .controls .row {
    display:flex;
    gap:12px;
  }

  .action-btn {
    background:#4a82ff;
    color:#fff;
    padding:10px 18px;
    border-radius:10px;
    border:none;
    font-weight:700;
    cursor:pointer;
    box-shadow:0 6px 16px rgba(74,130,255,0.18);
  }

  .action-btn:active{transform:translateY(1px)}
  .score {margin-top:8px;font-size:18px;font-weight:700;color:#071133}

  /* Mobile friendly */
  @media (max-width:420px){
    .game-card{width:92%}
    canvas#tetrisCanvas{width:100%}
  }
</style>
</head>
<body>

<!-- EXACT TASKBAR -->
<header class="topbar">
  <div class="left">
    <div class="logo">üéÆ</div>
    <div class="site">Rachit.Fun</div>
  </div>

  <div class="right">
    <label style="display:flex;align-items:center;gap:8px;font-weight:700">
      BG
      <input id="bgPicker" class="color-picker" type="color" value="#f7fbff" />
    </label>

    <button class="btn" id="homeBtn">Home</button>
    <button class="btn" id="resetAllBtn">Reset All</button>
  </div>
</header>

<!-- MAIN -->
<div class="main">
  <div class="title">TETRIS</div>

  <div class="game-card" role="main" aria-label="Tetris game">
    <!-- Canvas sized by JS to cells*block -->
    <canvas id="tetrisCanvas" width="300" height="600"></canvas>

    <!-- Buttons BELOW the game as you requested -->
    <div class="controls" aria-hidden="false">
      <div class="row">
        <button class="action-btn" id="startBtn">Start</button>
        <button class="action-btn" id="pauseBtn">Pause</button>
        <button class="action-btn" id="resumeBtn">Resume</button>
      </div>

      <div class="score" id="score">Score: 0</div>
      <div style="margin-top:8px;font-size:13px;color:#475569">Controls: ‚Üê ‚Üí (move) ‚Ä¢ ‚Üì (soft drop) ‚Ä¢ ‚Üë (rotate)</div>
    </div>
  </div>
</div>

<script>
/* ----------------- Persist BG (unchanged behavior) ----------------- */
const BG_KEY = 'rachit_bg';
const bgPicker = document.getElementById('bgPicker');
const saved = localStorage.getItem(BG_KEY);
if (saved) {
  document.body.style.background = saved;
  bgPicker.value = saved;
}
bgPicker.addEventListener('input', e => {
  document.body.style.background = e.target.value;
  localStorage.setItem(BG_KEY, e.target.value);
});
document.getElementById('homeBtn').addEventListener('click', ()=> location.href='index.html');
document.getElementById('resetAllBtn').addEventListener('click', ()=> {
  if (!confirm('Reset everything? This clears BG setting.')) return;
  localStorage.removeItem(BG_KEY);
  location.reload();
});

/* ----------------- TETRIS ENGINE (robust) ----------------- */
const canvas = document.getElementById('tetrisCanvas');
const ctx = canvas.getContext('2d');

const COLS = 10;
const ROWS = 20;
const BLOCK = 30; // px
canvas.width = COLS * BLOCK;
canvas.height = ROWS * BLOCK;

// board matrix: 0=empty or color string
let board = createMatrix(COLS, ROWS);

// Tetromino matrices (0/1)
const TETROMINOES = {
  I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
  J: [[1,0,0],[1,1,1],[0,0,0]],
  L: [[0,0,1],[1,1,1],[0,0,0]],
  O: [[1,1],[1,1]],
  S: [[0,1,1],[1,1,0]],
  T: [[0,1,0],[1,1,1]],
  Z: [[1,1,0],[0,1,1]]
};

const COLORS = {
  I:'#00f2ea', J:'#007aff', L:'#ff9500', O:'#ffd60a', S:'#34c759', T:'#bf5af2', Z:'#ff375f'
};

let player = {
  pos: {x:0,y:0},
  matrix: null,
  color: null
};

let dropInterval = 600;
let dropTimer = null;
let lastTime = 0;
let paused = false;
let score = 0;
const scoreEl = document.getElementById('score');

/* helpers */
function createMatrix(w,h){
  const m = [];
  for(let y=0;y<h;y++){
    m.push(new Array(w).fill(0));
  }
  return m;
}

function drawCell(x,y,color){
  ctx.fillStyle = color;
  ctx.fillRect(x*BLOCK, y*BLOCK, BLOCK, BLOCK);
  ctx.strokeStyle = 'rgba(0,0,0,0.06)';
  ctx.strokeRect(x*BLOCK, y*BLOCK, BLOCK, BLOCK);
}

function drawBoard(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // draw board cells
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const cell = board[y][x];
      if(cell){
        drawCell(x,y,cell);
      } else {
        // optional grid lines background
        ctx.fillStyle = '#ffffff00';
        ctx.fillRect(x*BLOCK,y*BLOCK,BLOCK,BLOCK);
        ctx.strokeStyle = 'rgba(0,0,0,0.06)';
        ctx.strokeRect(x*BLOCK,y*BLOCK,BLOCK,BLOCK);
      }
    }
  }
  // draw current piece
  if(player.matrix){
    for(let y=0;y<player.matrix.length;y++){
      for(let x=0;x<player.matrix[y].length;x++){
        if(player.matrix[y][x]){
          drawCell(player.pos.x + x, player.pos.y + y, player.color);
        }
      }
    }
  }
}

/* collision: test if matrix at position collides */
function collide(matrix, offsetX, offsetY){
  for(let y=0;y<matrix.length;y++){
    for(let x=0;x<matrix[y].length;x++){
      if(matrix[y][x]){
        const bx = offsetX + x;
        const by = offsetY + y;
        if(bx < 0 || bx >= COLS || by >= ROWS) return true;
        if(by >= 0 && board[by][bx]) return true;
      }
    }
  }
  return false;
}

/* merge piece into board */
function merge(matrix, offsetX, offsetY, color){
  for(let y=0;y<matrix.length;y++){
    for(let x=0;x<matrix[y].length;x++){
      if(matrix[y][x] && offsetY + y >= 0){
        board[offsetY+y][offsetX+x] = color;
      }
    }
  }
}

/* rotate matrix CW */
function rotateMatrix(matrix){
  const n = matrix.length;
  const res = Array.from({length:n},()=>Array(n).fill(0));
  for(let y=0;y<n;y++){
    for(let x=0;x<n;x++){
      res[x][n-1-y] = (matrix[y][x] || 0);
    }
  }
  return res;
}

/* spawn new random piece */
function spawnPiece(){
  const types = Object.keys(TETROMINOES);
  const t = types[Math.floor(Math.random()*types.length)];
  const m = copyMatrix(TETROMINOES[t]);
  player.matrix = m;
  player.color = COLORS[t];
  // spawn near top center
  player.pos.x = Math.floor((COLS - m[0].length)/2);
  player.pos.y = - topEmptyRows(m); // allow matrix to be partly above screen
  // if immediate collision => game over
  if(collide(player.matrix, player.pos.x, player.pos.y)){
    gameOver();
  }
}

/* copy 2D array */
function copyMatrix(m){
  return m.map(r=>r.slice());
}

/* count empty top rows for spawn */
function topEmptyRows(m){
  let count=0;
  for(let y=0;y<m.length;y++){
    if(m[y].some(v=>v)) break;
    count++;
  }
  return count;
}

/* clear full lines and score */
function clearLines(){
  let lines = 0;
  for(let y = ROWS-1; y>=0; y--){
    if(board[y].every(c=>c)){
      // remove row
      board.splice(y,1);
      board.unshift(new Array(COLS).fill(0));
      lines++;
      y++; // recheck same index after unshift
    }
  }
  if(lines){
    score += lines * 100;
    scoreEl.textContent = 'Score: '+score;
    // speed up a little every 5 lines (optional)
    // dropInterval = Math.max(100, dropInterval - lines*5);
    // reset interval if running
    if(dropTimer) { clearInterval(dropTimer); dropTimer = setInterval(gameDrop, dropInterval); }
  }
}

/* piece movement helpers */
function move(dx){
  if(!player.matrix) return;
  if(!collide(player.matrix, player.pos.x + dx, player.pos.y)){
    player.pos.x += dx;
  }
}
function softDrop(){
  if(!player.matrix) return;
  if(!collide(player.matrix, player.pos.x, player.pos.y + 1)){
    player.pos.y++;
  } else {
    // lock
    lockPiece();
  }
}

/* rotate with simple wall-kick attempts */
function rotatePiece(){
  if(!player.matrix) return;
  const rotated = rotateMatrix(padToSquare(player.matrix));
  // try offsets: 0, -1, +1, -2, +2
  const kicks = [0, -1, 1, -2, 2];
  for(let k=0;k<kicks.length;k++){
    const nx = player.pos.x + kicks[k];
    const ny = player.pos.y;
    if(!collide(rotated, nx, ny)){
      player.matrix = cropMatrix(rotated);
      player.pos.x = nx;
      return;
    }
  }
  // if none worked, rotation fails
}

/* lock piece onto board */
function lockPiece(){
  merge(player.matrix, player.pos.x, player.pos.y, player.color);
  clearLines();
  spawnPiece();
}

/* pad rectangular matrix to square (for rotate) */
function padToSquare(m){
  const n = Math.max(m.length, m[0].length);
  const res = Array.from({length:n},()=>Array(n).fill(0));
  for(let y=0;y<m.length;y++){
    for(let x=0;x<m[y].length;x++){
      res[y][x] = m[y][x];
    }
  }
  return res;
}

/* crop empty outer rows/cols (to keep piece small) */
function cropMatrix(m){
  // remove empty top rows
  while(m.length && m[0].every(v=>v===0)) m.shift();
  // remove empty bottom rows
  while(m.length && m[m.length-1].every(v=>v===0)) m.pop();
  // remove empty left cols
  while(m[0] && m.every(row => row[0]===0)){
    for(let r=0;r<m.length;r++) m[r].shift();
  }
  // remove empty right cols
  while(m[0] && m.every(row => row[row.length-1]===0)){
    for(let r=0;r<m.length;r++) m[r].pop();
  }
  return m;
}

/* game loop drop */
function gameDrop(){
  if(paused) return;
  if(!player.matrix) return;
  if(!collide(player.matrix, player.pos.x, player.pos.y + 1)){
    player.pos.y++;
  } else {
    lockPiece();
  }
  drawBoard();
}

function drawBoard(){
  drawBoardBackground();
  // draw static board + piece
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      if(board[y][x]){
        drawCell(x,y, board[y][x]);
      } else {
        // draw empty cell background lightly
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(x*BLOCK,y*BLOCK,BLOCK,BLOCK);
        ctx.strokeStyle = 'rgba(0,0,0,0.06)';
        ctx.strokeRect(x*BLOCK,y*BLOCK,BLOCK,BLOCK);
      }
    }
  }
  // piece
  if(player.matrix){
    for(let y=0;y<player.matrix.length;y++){
      for(let x=0;x<player.matrix[y].length;x++){
        if(player.matrix[y][x]){
          drawCell(player.pos.x + x, player.pos.y + y, player.color);
        }
      }
    }
  }
}

/* simpler background draw */
function drawBoardBackground(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // optional subtle background; grid is drawn above
}

/* start/pause/resume */
function startGame(){
  // reset
  board = createMatrix(COLS, ROWS);
  score = 0;
  scoreEl.textContent = 'Score: 0';
  dropInterval = 600;
  paused = false;
  player.matrix = null;
  spawnPiece();
  drawBoard();
  if(dropTimer) clearInterval(dropTimer);
  dropTimer = setInterval(gameDrop, dropInterval);
}

function pauseGame(){
  paused = true;
}

function resumeGame(){
  if(!player.matrix) return;
  paused = false;
}

function gameOver(){
  // stop loop
  if(dropTimer) clearInterval(dropTimer);
  dropTimer = null;
  alert('Game Over! Score: ' + score);
  // keep board; user can start new game
}

/* keyboard controls */
document.addEventListener('keydown', (e) => {
  if(!player.matrix) return;
  if(e.key === 'ArrowLeft'){ move(-1); drawBoard(); }
  else if(e.key === 'ArrowRight'){ move(1); drawBoard(); }
  else if(e.key === 'ArrowDown'){ softDrop(); drawBoard(); }
  else if(e.key === 'ArrowUp'){ rotatePiece(); drawBoard(); }
});

/* small helpers to fill matrix definitions with numbers 1/0 */
function normalizeTetrominoes(){
  for(const k in TETROMINOES){
    // ensure each row is array of ints
    TETROMINOES[k] = TETROMINOES[k].map(row => row.map(v => v ? 1 : 0));
  }
}
normalizeTetrominoes();

/* attach buttons */
document.getElementById('startBtn').addEventListener('click', ()=> startGame());
document.getElementById('pauseBtn').addEventListener('click', ()=> pauseGame());
document.getElementById('resumeBtn').addEventListener('click', ()=> resumeGame());

/* initial draw */
drawBoard();

</script>
</body>
</html>


