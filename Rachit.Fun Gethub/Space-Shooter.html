<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rachit.Fun ‚Äî Space Shooter (Final)</title>
<style>
  :root{--card:#fff}
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:#f7fbff;color:#071133}
  /* exact ribbon style used in MazeEscape (your provided topbar) */
  .topbar{ display:flex; justify-content:space-between; align-items:center; padding:12px 20px; background:transparent; border-bottom:1px solid rgba(0,0,0,0.03); position:sticky; top:0; z-index:50; }
  .left { display:flex; align-items:center; gap:12px; font-weight:800; }
  .left .logo{font-size:20px}
  .left .site{font-size:20px}
  .right { display:flex; align-items:center; gap:10px; }
  .color-picker{ width:36px; height:28px; border-radius:8px; border:1px solid #ccc; padding:0; }
  .score-pill{padding:6px 10px;border-radius:999px;background:linear-gradient(180deg,#fff,#f1f5f9);border:1px solid rgba(0,0,0,0.06);font-weight:700}
  .btn{ background:var(--card); border:1px solid rgba(0,0,0,0.06); padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:700; }

  /* page layout */
  .wrap{max-width:980px;margin:18px auto;padding:12px;display:flex;flex-direction:column;align-items:center;gap:10px}
  h1{margin:6px 0 0 0;font-size:28px}

  /* game over message - above controls */
  #gameOverMsg{height:24px;font-weight:900;color:#b91c1c;margin-top:6px}

  /* controls (above the game area) */
  .controls{
    display:flex;
    gap:10px;
    align-items:center;
    flex-wrap:wrap;
    justify-content:center;
  }
  .action{padding:10px 14px;border-radius:10px;border:1px solid rgba(0,0,0,0.06);background:#fff;font-weight:800;cursor:pointer}
  .action.primary{background:linear-gradient(90deg,#0ea5a3,#06b6b4);color:#fff;border:none}

  select{padding:8px 10px;border-radius:8px;border:1px solid rgba(0,0,0,0.06);font-weight:800;background:#fff}

  .text-input{padding:8px;border-radius:8px;border:1px solid rgba(0,0,0,0.06);min-width:220px}

  /* game frame */
  .game-frame{width:360px;height:540px;background:#020205;border-radius:12px;overflow:hidden;position:relative;border:6px solid rgba(0,0,0,0.06);box-shadow:0 18px 40px rgba(9,25,51,0.06)}
  canvas{display:block;width:100%;height:100%;touch-action:none}

  .status-row{display:flex;gap:12px;align-items:center;justify-content:center;margin-top:10px;font-weight:800}
  .pill{background:#fff;padding:8px 12px;border-radius:10px;border:1px solid rgba(0,0,0,0.06)}

  .muted{font-size:13px;color:#64748b}

  @media (max-width:420px){
    .game-frame{width:320px;height:480px}
    .text-input{min-width:140px}
  }
</style>
</head>
<body>

<!-- YOUR EXACT TOPBAR (unchanged) -->
<header class="topbar">
  <div class="left">
    <div class="logo">üéÆ</div>
    <div class="site">Rachit.Fun</div>
  </div>
  <div class="right">
    <label style="display:flex;align-items:center;gap:8px;font-weight:700">
      BG
      <input id="bgPicker" class="color-picker" type="color" value="#f7fbff" />
    </label>
    <button class="btn" id="homeBtn">Home</button>
    <button class="btn" id="resetAllBtn">Reset All</button>
  </div>
</header>

<!-- GAME UI -->
<div class="wrap">
  <h1>üöÄ Space Shooter</h1>

  <!-- Game Over message (Option B -> above buttons) -->
  <div id="gameOverMsg"></div>

  <!-- Controls row -->
  <div class="controls" role="toolbar" aria-label="game controls">
    <button id="startBtn" class="action primary">Start</button>
    <button id="pauseBtn" class="action" disabled>Pause</button>
    <button id="resumeBtn" class="action" disabled>Resume</button>
    <button id="resetBtn" class="action">Reset</button>

    <label style="display:flex;align-items:center;gap:8px;font-weight:800">
      Difficulty
      <select id="difficulty">
        <option value="easy">Easy</option>
        <option value="medium" selected>Medium</option>
        <option value="hard">Hard</option>
      </select>
    </label>

    <label style="display:flex;align-items:center;gap:8px;font-weight:800">
      Auto-Fire
      <select id="autoFireSel">
        <option value="on" selected>ON</option>
        <option value="off">OFF</option>
      </select>
    </label>
  </div>

  <!-- Text bar (you asked to keep it exactly) -->
  <div style="display:flex;justify-content:center;margin-top:8px">
    <input id="textBar" class="text-input" placeholder="Type here (text bar)" />
  </div>

  <!-- Game canvas -->
  <div class="game-frame" id="frame" aria-label="space shooter screen">
    <canvas id="gameCanvas" width="360" height="540" aria-label="game canvas"></canvas>
  </div>

  <!-- Score / info -->
  <div class="status-row">
    <div class="pill">Score: <span id="score">0</span></div>
    <div class="pill">Enemies: <span id="enemyCount">0</span></div>
    <div class="pill">Best: <span id="best">0</span></div>
  </div>

  <div class="muted">Use ‚Üê ‚Üí to move. Auto-Fire ON = continuous shooting. Auto-Fire OFF = press Space to shoot.</div>
</div>

<!-- Persist BG script (your exact logic) + game script -->
<script>
/* ---------- Persist background exactly like MazeEscape (your provided snippet) ---------- */
const BG_KEY = 'rachit_bg';
const bgPicker = document.getElementById('bgPicker');
const saved = localStorage.getItem(BG_KEY);
if (saved) { document.body.style.background = saved; bgPicker.value = saved; }
bgPicker.addEventListener('input', e => { document.body.style.background = e.target.value; localStorage.setItem(BG_KEY, e.target.value); });
document.getElementById('homeBtn').addEventListener('click', () => { window.location.href = 'index.html'; });
document.getElementById('resetAllBtn').addEventListener('click', () => { if (!confirm('Reset everything? This clears BG setting.')) return; localStorage.removeItem(BG_KEY); location.reload(); });

/* ---------- Space Shooter Game (final) ---------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resumeBtn = document.getElementById('resumeBtn');
const resetBtn = document.getElementById('resetBtn');
const difficultySel = document.getElementById('difficulty');
const autoFireSel = document.getElementById('autoFireSel');
const gameOverMsg = document.getElementById('gameOverMsg');
const scoreEl = document.getElementById('score');
const enemyCountEl = document.getElementById('enemyCount');
const bestEl = document.getElementById('best');
const textBar = document.getElementById('textBar');

const W = canvas.width;
const H = canvas.height;

let rafId = null;
let last = 0;
let running = false;
let paused = false;

let player, bullets, enemies;
let score = 0;
let best = Number(localStorage.getItem('rachit_shooter_best') || 0);
bestEl.textContent = best;

let autoFire = true;
let fireInterval = null;

/* Difficulty settings */
const DIFF = {
  easy:   { spawnRate: 1200,  speed: 1.2, perSpawn: 1, fireRate: 220 },
  medium: { spawnRate: 900,   speed: 1.9, perSpawn: 1, fireRate: 160 },
  hard:   { spawnRate: 600,   speed: 3.0, perSpawn: 2, fireRate: 110 }
};

/* Initialize / reset game state */
function initState(){
  player = { x: W/2, y: H - 60, w: 34, h: 44, speed: 4.4, alive: true, fireCooldown: 0 };
  bullets = []; // {x,y,vy,w,h}
  enemies = []; // {x,y,w,h,vy,angle,rotSpeed}
  score = 0;
  scoreEl.textContent = score;
  enemyCountEl.textContent = enemies.length;
  gameOverMsg.textContent = '';
  textBar.value = textBar.value || ''; // keep whatever user typed
  cancelAutoFire();
}

/* Draw player as classic rocket (choice A) */
function drawPlayer(){
  const p = player;
  ctx.save();
  ctx.translate(p.x, p.y);
  // rocket body (triangle)
  ctx.fillStyle = '#00f5ff';
  ctx.beginPath();
  ctx.moveTo(0, -p.h/2);
  ctx.lineTo(-p.w/2, p.h/2);
  ctx.lineTo(p.w/2, p.h/2);
  ctx.closePath();
  ctx.fill();
  // cockpit
  ctx.fillStyle = '#012026';
  ctx.beginPath();
  ctx.arc(0, -2, 6, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}

/* Draw enemy invader style (choice A) */
function drawEnemy(e){
  ctx.save();
  ctx.translate(e.x + e.w/2, e.y + e.h/2);
  // main body (circle)
  ctx.fillStyle = '#ff4343';
  ctx.beginPath();
  ctx.ellipse(0, 0, e.w/2, e.h/2, 0, 0, Math.PI*2);
  ctx.fill();
  // eyes / legs
  ctx.fillStyle = '#2a0000';
  ctx.fillRect(-e.w*0.18, -e.h*0.08, e.w*0.12, e.h*0.16);
  ctx.fillRect(e.w*0.06, -e.h*0.08, e.w*0.12, e.h*0.16);
  // antenna
  ctx.beginPath();
  ctx.strokeStyle = '#ffdede';
  ctx.lineWidth = 2;
  ctx.moveTo(-e.w*0.2, -e.h*0.6);
  ctx.lineTo(-e.w*0.1, -e.h*0.9);
  ctx.moveTo(e.w*0.2, -e.h*0.6);
  ctx.lineTo(e.w*0.1, -e.h*0.9);
  ctx.stroke();
  ctx.restore();
}

/* Draw bullet */
function drawBullet(b){
  ctx.fillStyle = '#fff8a3';
  ctx.fillRect(b.x - b.w/2, b.y - b.h, b.w, b.h);
}

/* Add an enemy */
function spawnEnemy(){
  const w = 28 + Math.random()*12;
  const h = 22 + Math.random()*10;
  const x = 12 + Math.random() * (W - 24 - w);
  const y = - (20 + Math.random()*120);
  const d = DIFF[getDifficultyKey()];
  const vy = d.speed + Math.random()*0.6;
  const rotSpeed = (Math.random()-0.5)*0.06;
  enemies.push({ x, y, w, h, vy, angle: 0, rotSpeed });
}

/* Spawn batch according to difficulty */
let spawnTimer = 0;
function spawnBatch(){
  const d = DIFF[getDifficultyKey()];
  for(let i=0;i<d.perSpawn;i++) spawnEnemy();
}

/* helper to read difficulty key */
function getDifficultyKey(){
  const v = difficultySel.value;
  if(v === 'easy' || v === 'medium' || v === 'hard') return v;
  return 'medium';
}

/* Update bullets and enemies, collisions */
function update(dt){
  if(paused) return;

  // player fire cooldown and auto-fire
  player.fireCooldown = Math.max(0, player.fireCooldown - dt);
  if(autoFire && player.fireCooldown <= 0){
    const d = DIFF[getDifficultyKey()];
    shoot();
    player.fireCooldown = d.fireRate / 1000;
  }

  // update bullets
  for(let i = bullets.length -1; i>=0; i--){
    bullets[i].y += bullets[i].vy * dt * 60;
    if(bullets[i].y < -10) bullets.splice(i,1);
  }

  // update enemies
  for(let i = enemies.length -1; i>=0; i--){
    const e = enemies[i];
    e.y += e.vy * dt * 60;
    e.x += Math.sin(e.y * 0.01) * 0.3; // slight side movement
    e.angle += e.rotSpeed;

    // player collision (must DIE on touching)
    if(rectIntersect(player.x - player.w/2, player.y - player.h/2, player.w, player.h, e.x, e.y, e.w, e.h)){
      // instant death
      endGame();
      return;
    }

    // bullet collisions
    for(let j = bullets.length -1; j>=0; j--){
      const b = bullets[j];
      if(rectIntersect(b.x - b.w/2, b.y - b.h, b.w, b.h, e.x, e.y, e.w, e.h)){
        // remove enemy and bullet
        enemies.splice(i,1);
        bullets.splice(j,1);
        score += 10;
        scoreEl.textContent = score;
        if(score > best){ best = score; bestEl.textContent = best; localStorage.setItem('rachit_shooter_best', String(best)); }
        break;
      }
    }
    // remove if beyond bottom
    if(e.y > H + 80) enemies.splice(i,1);
  }

  // spawn timer
  spawnTimer -= dt*1000;
  if(spawnTimer <= 0){
    spawnBatch();
    const d = DIFF[getDifficultyKey()];
    spawnTimer = d.spawnRate;
  }

  // update enemy count
  enemyCountEl.textContent = enemies.length;
}

/* Render scene */
function render(){
  // background
  ctx.fillStyle = '#03040a';
  ctx.fillRect(0,0,W,H);

  // faint stars
  ctx.fillStyle = 'rgba(255,255,255,0.03)';
  for(let i=0;i<25;i++){
    const sx = (i*37 + 13) % W;
    const sy = (i*59 + 27) % H;
    ctx.fillRect(sx, sy, 1, 1);
  }

  // draw enemies
  enemies.forEach(e => drawEnemy(e));

  // draw bullets
  bullets.forEach(b => drawBullet(b));

  // draw player on top
  drawPlayer();
}

/* Main loop */
let lastTime = 0;
function loop(ts){
  if(!running) return;
  if(paused) { lastTime = ts; rafId = requestAnimationFrame(loop); return; }
  if(!lastTime) lastTime = ts;
  const dt = Math.min(0.032, (ts - lastTime)/1000); // cap delta
  lastTime = ts;

  update(dt);
  render();

  rafId = requestAnimationFrame(loop);
}

/* Shoots a bullet */
function shoot(){
  if(!running || paused) return;
  // small cooldown to prevent over-shoot
  if(player.fireCooldown > 0) return;
  bullets.push({ x: player.x, y: player.y - player.h/2 - 8, w: 6, h: 12, vy: -8 });
  // set a very small cooldown for manual spacing
  player.fireCooldown = 0.06;
}

/* Simple rect intersection */
function rectIntersect(x1,y1,w1,h1,x2,y2,w2,h2){
  return !(x2 > x1 + w1 || x2 + w2 < x1 || y2 > y1 + h1 || y2 + h2 < y1);
}

/* GAME controls */
function startGame(){
  initState();
  const diffKey = getDifficultyKey();
  const d = DIFF[diffKey];
  spawnTimer = d.spawnRate;
  running = true;
  paused = false;
  startBtn.disabled = true;
  pauseBtn.disabled = false;
  resumeBtn.disabled = true;
  autoFire = (autoFireSel.value === 'on');
  lastTime = 0;
  rafId = requestAnimationFrame(loop);
}
function pauseGame(){
  if(!running || paused) return;
  paused = true;
  pauseBtn.disabled = true;
  resumeBtn.disabled = false;
  gameOverMsg.textContent = 'PAUSED';
}
function resumeGame(){
  if(!running || !paused) return;
  paused = false;
  pauseBtn.disabled = false;
  resumeBtn.disabled = true;
  gameOverMsg.textContent = '';
  lastTime = 0;
}
function endGame(){
  running = false;
  paused = true;
  cancelAnimationFrame(rafId);
  rafId = null;
  gameOverMsg.textContent = 'üíÄ GAME OVER';
  startBtn.disabled = false;
  pauseBtn.disabled = true;
  resumeBtn.disabled = true;
}
function resetGame(){
  running = false;
  paused = false;
  cancelAnimationFrame(rafId);
  rafId = null;
  initState();
  render(); // clear frame
  startBtn.disabled = false;
  pauseBtn.disabled = true;
  resumeBtn.disabled = true;
  gameOverMsg.textContent = '';
  lastTime = 0;
}

/* Start/Stop auto-fire interval (used when changing auto-fire setting) */
function cancelAutoFire(){
  if(fireInterval){ clearInterval(fireInterval); fireInterval = null; }
}
function setupAutoFire(){
  cancelAutoFire();
  if(autoFireSel.value === 'on'){
    const d = DIFF[getDifficultyKey()];
    fireInterval = setInterval(()=>{ if(running && !paused) shoot(); }, d.fireRate);
  }
}

/* Input handling */
const keys = {};
window.addEventListener('keydown', (e)=>{
  keys[e.key] = true;
  if(e.key === ' '){
    if(!autoFireSel || autoFireSel.value === 'off'){
      shoot();
    }
    e.preventDefault();
  }
  if(e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A'){ player.x = Math.max(player.w/2 + 6, player.x - player.speed*1.6); }
  if(e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D'){ player.x = Math.min(W - player.w/2 - 6, player.x + player.speed*1.6); }
  if(e.key.toLowerCase() === 'p'){
    if(running && !paused) pauseGame(); else if(running && paused) resumeGame();
  }
});
window.addEventListener('keyup', (e)=>{ keys[e.key] = false; });

/* Pointer (touch/mouse) movement and hold for firing */
let pointerDown = false;
canvas.addEventListener('pointerdown', (e)=>{
  pointerDown = true;
  const rect = canvas.getBoundingClientRect();
  const px = (e.clientX - rect.left) * (W / rect.width);
  player.x = clamp(px, player.w/2 + 6, W - player.w/2 - 6);
  // set autoFire from dropdown
  if(autoFireSel.value === 'off') {
    // single tap -> shoot once
    shoot();
  } else {
    // if auto on, ensure interval is active
    setupAutoFire();
  }
});
canvas.addEventListener('pointermove', (e)=>{
  if(!pointerDown) return;
  const rect = canvas.getBoundingClientRect();
  const px = (e.clientX - rect.left) * (W / rect.width);
  player.x = clamp(px, player.w/2 + 6, W - player.w/2 - 6);
});
canvas.addEventListener('pointerup', ()=>{
  pointerDown = false;
  if(autoFireSel.value === 'on'){ /* keep auto-fire running via interval */ }
});
canvas.addEventListener('pointercancel', ()=>{ pointerDown=false; });

function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

/* Hook up controls */
startBtn.addEventListener('click', ()=>{ startGame(); setupAutoFire(); });
pauseBtn.addEventListener('click', pauseGame);
resumeBtn.addEventListener('click', resumeGame);
resetBtn.addEventListener('click', resetGame);

/* Difficulty / Auto-Fire change handlers */
difficultySel.addEventListener('change', ()=>{
  // immediate effect on spawn rate & speed for new spawns
  // adjust spawnTimer so next spawn respects new difficulty
  spawnTimer = DIFF[getDifficultyKey()].spawnRate;
  setupAutoFire();
});
autoFireSel.addEventListener('change', ()=>{
  autoFire = (autoFireSel.value === 'on');
  setupAutoFire();
});

/* Initialize screen and state */
function initState(){
  player = { x: W/2, y: H - 60, w: 34, h: 44, speed: 4.4, alive: true, fireCooldown: 0 };
  bullets = [];
  enemies = [];
  spawnTimer = DIFF[getDifficultyKey()].spawnRate;
  score = 0;
  scoreEl.textContent = score;
  enemyCountEl.textContent = enemies.length;
  gameOverMsg.textContent = '';
  cancelAutoFire();
  // prefill some enemies for feel
  for(let i=0;i<3;i++) spawnEnemy();
}
initState();
render();

/* Save best when leaving */
window.addEventListener('beforeunload', ()=>{ localStorage.setItem('rachit_shooter_best', String(best)); });

</script>
</body>
</html>
